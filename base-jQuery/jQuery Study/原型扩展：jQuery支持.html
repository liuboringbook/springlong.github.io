<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <title>原型扩展与兼容：jQuery支持 - jQuery使用文档</title>
    <link rel="stylesheet" href="public/css/main.css" />
    <link rel="stylesheet" href="public/css/codeView.css" />
    <script src="public/js/jquery.min.js"></script>
    <script src="public/js/jquery.extend.js"></script>
    <script src="public/js/jquery.snippet.min.js"></script>
</head>
<body>
<section id="instruction">
    <h1>jQuery使用文档——原型扩展与兼容：jQuery支持</h1>
    <p>在本文档的上一篇的讲解中，我们演示了自定义扩展与兼容处理的原型方法的使用和注意事项。</p>
    <p>在这篇文章中，我们将演示<strong>jQuery提供的兼容处理函数</strong>的使用，同时将介绍这些函数与上一篇中所讲解的原型方法的区别和联系。</p>
    <h2>jQuery提供的兼容处理函数：String对象</h2>
    <ol class="list">
        <li>
            <p class="title"><code>$.trim(str)</code></p>
            <p>去除目标字符串首尾两端的所有空格，并作为新的字符串返回（原字符串不受影响）。（返回类型：String）</p>
            <div class="params">
                <p>参数str：<span>（类型：String）</span>目标字符串；</p>
            </div>
            <p>该函数是对JavaScript原生提供的<code>String.prototype.trim()</code>方法的兼容处理，<b>建议使用原生方法代替该操作</b>。</p>
            <p class="demo">
                <code>$.trim("&nbsp;&nbsp;&nbsp;abc&nbsp;&nbsp;&nbsp;abc&nbsp;&nbsp;&nbsp;")</code>
                <span class="result"><code id="trim"></code></span>
            </p>
        </li>
    </ol>
    <h2>jQuery提供的兼容处理函数：Array对象</h2>
    <ol class="list">
        <li>
            <p class="title"><code>$.inArray(val, array[, fromIndex])</code></p>
            <p>返回目标数组中参数val的值第一次出现所在的索引位置，不存在则返回-1。（返回类型：Number）</p>
            <div class="params">
                <p>参数val：<span>（类型：Object）</span>需要进行查询的值；</p>
                <p>参数array：<span>（类型：Array）</span>目标数组；</p>
                <p>参数fromIndex：<span>（类型：Number，可选）</span>指定开始查找的索引位置，默认为0（为负数时表示从倒数位置开始检索）。</p>
            </div>
            <p>该函数是对JavaScript原生提供的<code>Array.prototype.indexOf()</code>方法的兼容处理，<b>建议使用原生方法代替该操作</b>。</p>
            <p class="demo">
                <code>$.inArray("1", [1, 2, 3, 4, 5])</code>
                <span class="result"><code id="indexOf1"></code></span>
            </p>
            <p class="demo">
                <code>$.inArray(1, [1, 2, 3, 4, 5])</code>
                <span class="result"><code id="indexOf2"></code></span>
            </p>
            <p class="demo">
                <code>$.inArray(5, [1, 2, 3, 4, 5])</code>
                <span class="result"><code id="indexOf3"></code></span>
            </p>
            <p class="demo">
                <code>$.inArray(5, [1, 2, 3, 4, 5], 4)</code>
                <span class="result"><code id="indexOf4"></code></span>
            </p>
            <p class="demo">
                <code>$.inArray(5, [1, 2, 3, 4, 5], 5)</code>
                <span class="result"><code id="indexOf5"></code></span>
            </p>
            <p class="demo">
                <code>$.inArray(4, [1, 2, 3, 4, 5], -1)</code>
                <span class="result"><code id="indexOf6"></code></span>
            </p>
            <p class="demo">
                <code>$.inArray(4, [1, 2, 3, 4, 5], -2)</code>
                <span class="result"><code id="indexOf7"></code></span>
            </p>
        </li>
        <li>
            <p class="title"><code>$.grep(array, function(item, i){}[, invert])</code></p>
            <p>遍历目标数组中的每一个元素，筛选出符合条件的所有元素并以新数组的形式返回（原数组不受影响）。（返回类型：Array）</p>
            <div class="params">
                <p>参数array：<span>（类型：Array）</span>目标数组；</p>
                <p>参数function(item, i){}：<span>（类型：Function）</span>回调函数；</p>
                <p class="level2">回调函数-参数item：当前项的值；</p>
                <p class="level2">回调函数-参数i：当前项的索引值；</p>
                <p class="level2">回调函数-this：window对象；</p>
                <p>参数invert：<span>（类型：Boolean，可选）</span>默认为false，此时返回回调函数返回true的所有元素；当该值为true时，将返回回调函数返回false的所有元素。</p>
            </div>
            <p>该函数是对JavaScript原生提供的<code>Array.prototype.filter()</code>方法的兼容处理，并提供了invert参数的扩展。<b>建议使用原生方法代替该操作。</b></p>
            <p class="demo">
                <code>$.grep([1, 2, 3, 4, 5], function(item, i){ return i &lt; 2; })</code>
                <span class="result"><code id="filter1"></code></span>
            </p>
            <p class="demo">
                <code>$.grep([1, 2, 3, 4, 5], function(item){ return item &gt; 2; })</code>
                <span class="result"><code id="filter2"></code></span>
            </p>
            <p class="demo">
                <code>$.grep([1, 2, 3, 4, 5], function(item){ return item &gt; 5; })</code>
                <span class="result"><code id="filter3"></code></span>
            </p>
            <p class="demo">
                <code>$.grep([1, 2, 3, 4, 5], function(item){ return item % 2 === 0; })</code>
                <span class="result"><code id="filter4"></code></span>
            </p>
            <p class="demo">
                <code>$.grep([1, 2, 3, 4, 5], function(item){ return item % 2 !== 0; }, false)</code>
                <span class="result"><code id="filter5"></code></span>
            </p>
            <p class="demo">
                <code>$.grep([1, 2, 3, 4, 5], function(item){ return item % 2 !== 0; }, true)</code>
                <span class="result"><code id="filter6"></code></span>
            </p>
        </li>
        <li>
            <p class="title"><code>$.map(array, function(item, i){})</code></p>
            <p>遍历目标数组中的每一个元素，并执行回调函数，最终将回调函数返回的值组合成新的数组并返回。（返回类型：Array）</p>
            <div class="params">
                <p>参数array：<span>（类型：Array|ArrayLike）</span>目标数组；</p>
                <p>参数function(item, i){}：<span>（类型：Function）</span>回调函数；</p>
                <p class="level2">回调函数-参数item：当前项的值；</p>
                <p class="level2">回调函数-参数i：当前项的索引值；</p>
                <p class="level2">回调函数-this：window对象；</p>
            </div>
            <p>该函数是对JavaScript原生提供的<code>Array.prototype.map()</code>方法的兼容处理，<b>不过存在以下4点不同：</b></p>
            <p>1. 原生方法中允许将回调函数返回的null或者undefined加入到新的数组中，而$.map()方法则将这两个特殊值做移除处理。</p>
            <p>2. 如果回调函数返回的是一个数组，那么$.map()方法将会把该数组的各个元素加入到最终的返回数组中，而原生方法则将该数组作为单个元素加入到最终的返回数组中。</p>
            <p>3. $.map()除了支持标准的数组外，还支持类似数组的的对象。</p>
            <p>4. 在jQuery 1.6及之后的版本中，$.map()方法还提供了对其他对象的遍历支持，而不再局限于数组或类似数组的的对象。</p>
            <p><b>另外需要注意的是：</b></p>
            <p>1. 在jQuery1.9.1~1.10.2版本的内部程序中对isArrayLike的判断有些Bug，空字符串被认为是isArrayLike，但在判断非空字符串时将导致错误异常。</p>
            <p>2. 将空字符串传递给array参数，$.map()方法可以正确处理，但将非空字符串传递给array参数时将导致错误异常。为了保险起见，如果需要对类似数组的的对象进行该操作，请先使用<code>$.makeArray()</code>方法将其转换为数组对象后再进行操作。示例代码如下：</p>
<pre class="jsCodeNum">
var likeArray = "abcdefg";
var realArray = $.makeArray(likeArray);
$.map(realArray, function(item, i)
{
    //do something
});
</pre>
            <p>3. 如果需要对jQuery元素集合进行类似的处理，请使用<code>jQuery.prototype.map()</code>方法，例如：<code>$(".book").map(callback)</code>。</p>
            <p>4. 由于该处理函数提供了比原生方法更为强大且更全面的功能，<strong>所以请使用该处理函数代替原生方法</strong>。</p>
            <p class="demo">
                <code>$.map([6, 7, 8, 9, 10], function(item, i){ return i; })</code>
                <span class="result"><code id="map1"></code></span>
            </p>
            <p class="demo">
                <code>$.map([6, 7, 8, 9, 10], function(item, i){ return i + 3; })</code>
                <span class="result"><code id="map2"></code></span>
            </p>
            <p class="demo">
                <code>$.map([6, 7, 8, 9, 10], function(item){ return item * 2; })</code>
                <span class="result"><code id="map3"></code></span>
            </p>
            <p class="demo">
                <code>$.map([6, 7, 8, 9, 10], function(item, i){ return item + i; })</code>
                <span class="result"><code id="map4"></code></span>
            </p>
            <p class="demo">
                <code>$.map([6, 7, 8, 9, 10], function(item, i){ return i > 2 ? item : null; })</code>
                <span class="result"><code id="map5"></code></span>
            </p>
            <p class="title title2"><code>$.map(object, function(value, key){})</code></p>
            <p>遍历目标对象的每一个成员，并执行回调函数，最终将回调函数返回的值组合成新的数组并返回。（返回类型：Array）</p>
            <div class="params">
                <p>参数object：<span>（类型：object）</span>目标对象；</p>
                <p>参数function(value, key){}：<span>（类型：Function）</span>回调函数；</p>
                <p class="level2">回调函数-参数value：当前项的值；</p>
                <p class="level2">回调函数-参数key：当前项的名称；</p>
                <p class="level2">回调函数-this：window对象；</p>
            </div>
            <p class="demo">
                <code>$.map({a:10, b:20, c:30}, function(value, key){ return key; })</code>
                <span class="result"><code id="map6"></code></span>
            </p>
            <p class="demo">
                <code>$.map({a:10, b:20, c:30}, function(value, key){ return value / 2; })</code>
                <span class="result"><code id="map7"></code></span>
            </p>
        </li>
        <li>
            <p class="title"><code>$.each(array, function(i, item){})</code></p>
            <p>遍历目标数组中的每一个元素，并执行回调函数。（返回类型：原遍历对象）</p>
            <div class="params">
                <p>参数array：<span>（类型：Array|ArrayLike）</span>目标数组；</p>
                <p>参数function(i, item){}：<span>（类型：Function）</span>回调函数；</p>
                <p class="level2">回调函数-参数i：当前项的索引值；</p>
                <p class="level2">回调函数-参数item：当前项的值；</p>
                <p class="level2">回调函数-this：当前项的值；</p>
            </div>
            <p>该处理函数囊括了JavaScript原生提供的<code>Array.prototype.forEach()</code>方法的功能，但该函数与原生方法的使用方式完全不同，<strong>主要有以下4点：</strong></p>
            <p>1. 参数方面：在该处理函数的回调函数中，提供的两个参数分别是当前项的索引和当前项的值，<b>与原生方法中参数的顺序相反</b>。</p>
            <p>2. this关键字：在该处理函数的回调函数中，this指向当前项的值，而原生方法中则指向window。</p>
            <p>3. $.each()方法不仅支持数组的遍历，同时也可以用于类似数组的的对象以及其他对象的遍历操作。</p>
            <p>4. $.each()方法还提供了终止遍历的条件，即当回调函数返回false时，将终止遍历操作，相当于循环中的break语句。</p>
            <p><b>另外需要注意的是：</b></p>
            <p>1. 在jQuery中，另外还有一个用于遍历的方法――<code>jQuery.prototype.each()</code>，该方法专门用于遍历jQuery元素集合。</p>
            <p>2. 由于$.each()方法的使用非常频繁，且功能和适用对象要远远强于原生的forEach()方法，<strong>所以请使用该处理函数代替原生方法</strong>。</p>
<pre class="jsCodeNum">
//下面的代码将依次弹出："0:a"、"1:b"、"2:c"
$.each(["a", "b", "c"], function(i, item)
{
    alert(i + ":" + item);
});

//上述代码我们也可以书写为下述格式
$.each(["a", "b", "c"], function(i)
{
    alert(i + ":" + this);
});
</pre>
            <p class="title title2"><code>$.each(object, function(key, value){})</code></p>
            <p>遍历目标对象中的每一个成员，并执行回调函数。（返回类型：原遍历对象）</p>
            <div class="params">
                <p>参数object：<span>（类型：object）</span>目标对象；</p>
                <p>参数function(key, value){}：<span>（类型：Function）</span>回调函数；</p>
                <p class="level2">回调函数-参数key：当前项的名称；</p>
                <p class="level2">回调函数-参数value：当前项的值；</p>
                <p class="level2">回调函数-this：当前项的值；</p>
            </div>
<pre class="jsCodeNum">
//下面的代码将依次弹出："name:Jerry"、"age:23"
$.each({name: "Jerry", age: 23}, function(key, value)
{
    alert(key + ":" + value);
});
</pre>
        </li>
        <li>
            <p class="title"><code>$.makeArray(object)</code></p>
            <p>将一个类似数组的对象转换为真正的数组（原对象的值不受影响）。（返回类型：Array）</p>
            <div class="params">
                <p>参数object：<span>（类型：Object）</span>目标对象；</p>
            </div>
            <p>当目标对象的参数类型为String、或者为非ArrayLike时，最终的返回结果将是该参数作为唯一元素的数组对象。</p>
            <p>在JavaScript中并没有类似的原生方法，该处理函数是jQuery扩展的一个实用方法。</p>
            <p></p>
<pre class="jsCodeNum">
//特殊情况下的转换
var arr1 = $.makeArray("abc");      //结果为：["abc"]
var arr2 = $.makeArray(window);     //结果为：[window]

//标准情况下的转换1
var obj = {"0": "a", "1": "b", "2": "c"};
obj.length = 3;
var arr3 = $.makeArray(obj);        //结果为：["a", "b", "c"]

//标准情况下的转换2
var test1 = $("p");
var test2 = $.makeArray(test1);
var type1 = $.type(test1);          //结果为：object
var type2 = $.type(test2);          //结果为：array
</pre>
        </li>
        <li>
            <p class="title"><code>$.merge(first, second)</code></p>
            <p>将两个数组的内容合并到第一个数组，并返回合并后的第一个数组。（返回类型：Array）</p>
            <div class="params">
                <p>参数first：<span>（类型：Array）</span>第一个数组（该数组的内容将会变更，合并之后将会包含第二个数组的内容）；</p>
                <p>参数second：<span>（类型：Array）</span>第二个数组（该数组不会被修改，但其中的内容会被合并到第一个数组）；</p>
            </div>
            <p>在JavaScript中并没有类似的原生方法，该处理函数是jQuery扩展的一个实用方法。</p>
            <p><b>由于合并操作将会影响到第一个数组的内容，如果不想破坏第一个数组，可以在合并之前先拷贝一个副本出来。</b></p>
            <p></p>
<pre class="jsCodeNum">
//注意：下面的arr1和arr2指向的其实是同一个数组
var arr1 = [1, 2, 3];
var arr2 = arr1;

//幸运的是，$.merge()方法也可以用于数组的克隆操作
//下面的代码使用了一个新的空数组来合并arr3的内容，从而有效地实现了arr4对arr3的克隆操作
var arr3 = [1, 2, 3];
var arr4 = $.merge([], arr3);

//数组合并操作案例1（第一个数组的内容将会变更）
var test1 = [1, 2, 3];                  //执行$.merge处理后的结果为：[1, 2, 3, 3, 2, 1]
var test2 = [3, 2, 1];                  //执行$.merge处理后的结果为：[3, 2, 1]
var result1 = $.merge(test1, test2);    //执行$.merge处理后的结果为：[1, 2, 3, 3, 2, 1]

//数组合并操作案例2（第一个数组的内容不会变更）
var test3 = [1, 2, 3];                  //执行$.merge处理后的结果为：[1, 2, 3]
var test4 = [3, 2, 1];                  //执行$.merge处理后的结果为：[3, 2, 1]
var result2 = $.merge($.merge([], test3), test4);    //执行$.merge处理后的结果为：[1, 2, 3, 3, 2, 1]
</pre>
        </li>
    </ol>
    <h2>jQuery提供的兼容处理函数：其他对象</h2>
    <ol class="list">
        <li>
            <p class="title"><code>$.contains(parent, child)</code></p>
            <p>判断作为父级节点的parent中，是否存在作为子节点的child。如果是则返回true，否则返回false。（返回类型：Boolean）</p>
            <div class="params">
                <p>参数parent：<span>（类型：HTMLElement）</span>父级节点；</p>
                <p>参数child：<span>（类型：HTMLElement）</span>子节点；</p>
            </div>
            <p>在下面的代码示例中，id为“instruction”的标签元素是存在的，而id为“noelement"的标签元素是不存在。</p>
            <p class="demo">
                <code>$.contains(document.body, document.getElementById("instruction"))</code>
                <span class="result"><code id="htmlContains1"></code></span>
            </p>
            <p class="demo">
                <code>$.contains(document.body, document.getElementById("noelement"))</code>
                <span class="result"><code id="htmlContains2"></code></span>
            </p>
            <p class="demo">
                <code>$.contains(document.body, document.body)</code>
                <span class="result"><code id="htmlContains3"></code></span>
            </p>
            <p>该函数是对JavaScript原生提供的<code>HTMLElement.prototype.contains()</code>方法的兼容处理，但同一元素进行比较时将返回<strong>false</strong>。<b>建议使用原生方法代替该操作。</b></p>
        </li>
    </ol>
</section>
<section class="codeView">
    <h2>程序代码：jQuery提供的兼容处理函数</h2>
    <pre class="jsCodeNum">
var core_version = "1.9.1",
    core_trim = core_version.trim,
    core_deletedIds = [],
    core_concat = core_deletedIds.concat,
    core_push = core_deletedIds.push,
    core_indexOf = core_deletedIds.indexOf;

function isArraylike( obj ) {
    var length = obj.length,
        type = jQuery.type( obj );

    if ( jQuery.isWindow( obj ) ) {
        return false;
    }

    if ( obj.nodeType === 1 &amp;&amp; length ) {
        return true;
    }

    return type === "array" || type !== "function" &amp;&amp;
        ( length === 0 ||
        typeof length === "number" &amp;&amp; length > 0 &amp;&amp; ( length - 1 ) in obj );
}

jQuery.extend({

    // args is for internal usage only
    each: function( obj, callback, args ) {
        var value,
            i = 0,
            length = obj.length,
            isArray = isArraylike( obj );

        if ( args ) {
            if ( isArray ) {
                for ( ; i &lt; length; i++ ) {
                    value = callback.apply( obj[ i ], args );

                    if ( value === false ) {
                        break;
                    }
                }
            } else {
                for ( i in obj ) {
                    value = callback.apply( obj[ i ], args );

                    if ( value === false ) {
                        break;
                    }
                }
            }

        // A special, fast, case for the most common use of each
        } else {
            if ( isArray ) {
                for ( ; i &lt; length; i++ ) {
                    value = callback.call( obj[ i ], i, obj[ i ] );

                    if ( value === false ) {
                        break;
                    }
                }
            } else {
                for ( i in obj ) {
                    value = callback.call( obj[ i ], i, obj[ i ] );

                    if ( value === false ) {
                        break;
                    }
                }
            }
        }

        return obj;
    },

    // Use native String.trim function wherever possible
    trim: core_trim &amp;&amp; !core_trim.call("\uFEFF\xA0") ?
        function( text ) {
            return text == null ? "" : core_trim.call( text );
        } :
        // Otherwise use our own trimming functionality
        function( text ) {
            return text == null ? "" : ( text + "" ).replace( rtrim, "" );
        },

    // results is for internal usage only
    makeArray: function( arr, results ) {
        var ret = results || [];

        if ( arr != null ) {
            if ( isArraylike( Object(arr) ) ) {
                jQuery.merge( ret,
                    typeof arr === "string" ?
                    [ arr ] : arr
                );
            } else {
                core_push.call( ret, arr );
            }
        }

        return ret;
    },

    inArray: function( elem, arr, i ) {
        var len;

        if ( arr ) {
            if ( core_indexOf ) {
                return core_indexOf.call( arr, elem, i );
            }

            len = arr.length;
            i = i ? i &lt; 0 ? Math.max( 0, len + i ) : i : 0;

            for ( ; i &lt; len; i++ ) {
                // Skip accessing in sparse arrays
                if ( i in arr &amp;&amp; arr[ i ] === elem ) {
                    return i;
                }
            }
        }

        return -1;
    },

    merge: function( first, second ) {
        var l = second.length,
            i = first.length,
            j = 0;

        if ( typeof l === "number" ) {
            for ( ; j &lt; l; j++ ) {
                first[ i++ ] = second[ j ];
            }
        } else {
            while ( second[j] !== undefined ) {
                first[ i++ ] = second[ j++ ];
            }
        }

        first.length = i;

        return first;
    },

    grep: function( elems, callback, inv ) {
        var retVal,
            ret = [],
            i = 0,
            length = elems.length;
        inv = !!inv;

        // Go through the array, only saving the items
        // that pass the validator function
        for ( ; i &lt; length; i++ ) {
            retVal = !!callback( elems[ i ], i );
            if ( inv !== retVal ) {
                ret.push( elems[ i ] );
            }
        }

        return ret;
    },

    // arg is for internal usage only
    map: function( elems, callback, arg ) {
        var value,
            i = 0,
            length = elems.length,
            isArray = isArraylike( elems ),
            ret = [];

        // Go through the array, translating each of the items to their
        if ( isArray ) {
            for ( ; i &lt; length; i++ ) {
                value = callback( elems[ i ], i, arg );

                if ( value != null ) {
                    ret[ ret.length ] = value;
                }
            }

        // Go through every key on the object,
        } else {
            for ( i in elems ) {
                value = callback( elems[ i ], i, arg );

                if ( value != null ) {
                    ret[ ret.length ] = value;
                }
            }
        }

        // Flatten any nested arrays
        return core_concat.apply( [], ret );
    }

});
</pre>
</section>
<script src="public/js/main.js"></script>
<script>
    jQuery(function($)
    {
        //=============================================================================================
        //String对象的原型兼容与扩展
        $("#trim").html($.trim("   abc   abc   ").replace(/ /g, "&nbsp;"));


        //=============================================================================================
        //Array对象的原型兼容与扩展
        $("#indexOf1").html($.inArray("1", [1, 2, 3, 4, 5]));
        $("#indexOf2").html($.inArray(1, [1, 2, 3, 4, 5]));
        $("#indexOf3").html($.inArray(5, [1, 2, 3, 4, 5]));
        $("#indexOf4").html($.inArray(5, [1, 2, 3, 4, 5], 4));
        $("#indexOf5").html($.inArray(5, [1, 2, 3, 4, 5], 5));
        $("#indexOf6").html($.inArray(4, [1, 2, 3, 4, 5], -1));
        $("#indexOf7").html($.inArray(4, [1, 2, 3, 4, 5], -2));

        $("#filter1").html("[" + $.grep([1, 2, 3, 4, 5], function(item, i){ return i < 2; }) + "]");
        $("#filter2").html("[" + $.grep([1, 2, 3, 4, 5], function(item){ return item > 2; }) + "]");
        $("#filter3").html("[" + $.grep([1, 2, 3, 4, 5], function(item){ return item > 5; }) + "]");
        $("#filter4").html("[" + $.grep([1, 2, 3, 4, 5], function(item){ return item % 2 === 0; }) + "]");
        $("#filter5").html("[" + $.grep([1, 2, 3, 4, 5], function(item){ return item % 2 !== 0; }, false) + "]");
        $("#filter6").html("[" + $.grep([1, 2, 3, 4, 5], function(item){ return item % 2 !== 0; }, true) + "]");

        $("#map1").html("[" + $.map([6, 7, 8, 9, 10], function(item, i){ return i; }) + "]");
        $("#map2").html("[" + $.map([6, 7, 8, 9, 10], function(item, i){ return i + 3; }) + "]");
        $("#map3").html("[" + $.map([6, 7, 8, 9, 10], function(item){ return item * 2; }) + "]");
        $("#map4").html("[" + $.map([6, 7, 8, 9, 10], function(item, i){ return item + i; }) + "]");
        $("#map5").html("[" + $.map([6, 7, 8, 9, 10], function(item, i){ return i > 2 ? item: null; }) + "]");
        $("#map6").html("[" + $.map({a:10, b:20, c:30}, function(value, key){ return key; }) + "]");
        $("#map7").html("[" + $.map({a:10, b:20, c:30}, function(value, key){ return value / 2; }) + "]");


        //=============================================================================================
        //其他对象的原型兼容与扩展
        $("#htmlContains1").html($.contains(document.body, document.getElementById("instruction")) + "");
        $("#htmlContains2").html($.contains(document.body, document.getElementById("noelement")) + "");
        $("#htmlContains3").html($.contains(document.body, document.body) + "");


        //=============================================================================================
        //代码着色
        $("pre.jsCode").snippet("javascript", {style: "custom_js", showNum: false});
        $("pre.jsCodeNum").snippet("javascript", {style: "custom_js"});
    });
</script>
</body>
</html>